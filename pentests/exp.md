---
title: Exploit notes
author: gros
layout: post
---

### IP control

```
- saved rip
- ptrs in got table
- malloc_hook (triggered f.e. with printf with large string), free_hook etc
- fini array
- vtable in _IO_FILE (stdin, stderr...), fe. flush in stdout vtable
- classes vtables
- atexit, onexit
- handler for custom format in printf
```

### Random stuff

* bugs
    * strings with nullbyte

    * buffer overflow

    * format string

    * UAF

    * double free

    * integer overflow

    * abs(-INT_MIN) == -INT_MIN
        ```
        c = ctypes.c_int32(-2**31)  # -2**63
        return ctypes.c_int32( ((c.value ^ (c.value >> 31)) - (c.value >> 31)) )
        ```

    * types confusion

    * uninitialized memory

    + [shared_ptr misuse](https://blog.scrt.ch/2017/01/27/exploiting-a-misused-c-shared-pointer-on-windows-10/): when two different shared_ptrs points to the same object and one of them decrements refcount to 0 -> free -> UAF

* techniques / tricks

    + fmt string bug without stack control:
        ```
        initial stack:
        stack[x   ] == 0xffff5566: 0xffff5576 -> 0xabcd
        stack[x+16] == 0xffff5576: 0xabcd

        we can %x$n and change 0xabcd to write_where, like 0x55555dead:
        stack[x   ] == 0xffff5566: 0xffff5576 -> 0x55555dead
        stack[x+16] == 0xffff5576: 0x55555dead -> 0x0

        and now we can %x+19$n and change value at 0x55555dead to write_what
        ```

    * partial overwrites

    * dynamic resovler (return to dl_resolve)

    * dt_debug traversal: find ptr in dynamic section, _r_debug struct...

    * when stdin and stdout are closed / redirected to stderr:
        * blind exploitation, like leak something in memory byte-by-byte by using infinite loops and connection closing
        * open /dev/pts/X twice
        * change used _IO_FILE->_fileno to stdin/stdout

    * can't controll some register directly with ROP gadgets? Try to control it by jumping to the original code or some libc function (like atoi can control rax)

    * in init func there are nice rop gadgets (sometimes called return to csu - __libc_csu_init):

        ```
        pop rbx,rbp,r12,r13,r14,r15
        mov rdx, r13
        mov rsi, r14
        mov edi, r15
        call [r12+rbx*8]
        ```

    * you can open "/proc/self/mem" on main function address with mode=2 and write there a shellcode

    * [FILE's vtable checks bypass](https://dhavalkapil.com/blogs/FILE-Structure-Exploitation/)

    + ASLR bypass
        * memory leak (bum, unexpected)
        * [AnC](https://www.vusec.net/projects/anc/)
        * [PREFETCHT0 asm instruction](https://david942j.blogspot.com/2017/03/write-up-0ctf-2017-qual-pwn647-pages.html)

    + scanf with "%d" -> you can send "-" or "+" and the value won't change

    + restriced shellcode
        + try to call `read(0, &shellcode, X)` to bypass restrictions (it is easier than writing full restricted shellcode) 
        + [self-modifying](https://lordidiot.github.io/2019-02-03/nullcon-hackim-ctf-2019/#easy-shell)

    + remote `read` may split data into chunks (some exploits may fail because of that)

    * sigreturn ROP


### Heap notes
```
Arena - structs shared between threads, one arena may have many heaps 
Heap - single contiguous memory region holding (coalesceable) malloc_chunks.
    It is allocated with mmap() and always starts at an address aligned to HEAP_MAX_SIZE.
    One heap is in exactly one arena.

For 32 bit systems:
     Max numbers of arenas = 2 * number of cores.
     SIZE_SZ = 4
For 64 bit systems:
     Max numbers of arenas = 8 * number of cores.
     SIZE_SZ = 8

CHUNKS
------------------------
struct malloc_chunk {
    INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if P == 0).  */
    INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. 3LSB: N,M,P*/
    /* A(NON_MAIN_ARENA), M(IS_MMAPPED), P(PREV_INUSE) */

    struct malloc_chunk* fd;         /* double links -- used only if free. */
    struct malloc_chunk* bk;

    /* Only used for large blocks: pointer to next larger size.  */
    struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
    struct malloc_chunk* bk_nextsize;
};

taken from malloc.c:

used chunk
    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of previous chunk, if unallocated (P clear)  |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of chunk, in bytes                     |A|M|P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             User data starts here...                          .
        .                                                               .
        .             (malloc_usable_size() bytes)                      .
        .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             (size of chunk, but used for application data)    |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of next chunk, in bytes                |A|0|1|
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


free chunk
    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of previous chunk, if unallocated (P clear)  |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `head:' |             Size of chunk, in bytes                     |A|0|P|
      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Forward pointer to next chunk in list             |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Back pointer to previous chunk in list            |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Unused space (may be 0 bytes long)                .
        .                                                               .
        .                                                               |
nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    `foot:' |             Size of chunk, in bytes                           |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of next chunk, in bytes                |A|0|0|
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


A bit - set if chunk belongs to thread arena
N bit - set if chunk was mapped (other bits are ignored then)
P bit - set if previous chunk is in use, otherwise previous chunk size is correct


BINS
------------------------
128 bins total
64 bins of size       8
32 bins of size      64
16 bins of size     512
 8 bins of size    4096
 4 bins of size   32768
 2 bins of size  262144
 1 bin  of size what's left


not existing bin(1)
unsorted bin(1):
* works as queue for chunks > fastbins
* chunk get in on free or consolidation
* chunk get out on malloc 

fastbins(10):
* below 80 * SIZE_SZ / 4
* bins of sizes 16-80, +8 each
* no coalescing (only in bulk)
* single linked
* 0x30-0x38 are all rounded to 0x40 on x64
    ```
    idx 0   bytes 0..24 (64-bit) or 0..12 (32-bit)
    idx 1   bytes 25..40 or 13..20
    idx 2   bytes 41..56 or 21..28
    ```

smallbin(62)
* less than 512
* from 16, +8 each
* coalescing

large bins(63)
* coalescing
* ordered


HOUSES
------------------------
The House of Prime: Requires two free's of chunks containing attacker controlled size fields, followed by a call to malloc.

The House of Mind: Requires the manipulation of the program into repeatedly allocating new memory.

The House of Force: Requires that we can overwrite the top chunk, that there is one malloc call with a user controllable size, and finally requires another call to malloc.

The House of Lore: Again not applicable to our example program.

The House of Spirit: One assumption is that the attacker controls a pointer given to free, so again this technique cannot be used.

The House of Chaos: This isn't actually a technique, just a section in the article :)
------------------------



FASTBIN
------------------------
* abusing the fastbin freelist (two times same value in fastbins list):
    + require:
        + double-free on chunk (fastbin size)
        + variable near write_where with value close to fastbin size 

    + malloc two chunks (same size, say 0x40)
    + free chunk1, chunk2, chunk1 (double free vuln);   # now fastbin list is HEAD->chunk1->chunk2->chunk1
    + d = malloc(size); malloc(size);                   # now the list is HEAD->chunk1 and we control content (fd, bk) of chunk1
    + write_where = 0x40                                # (or semething near fastbin size)
    + *d = &write_where - SIZE_SZ; 
    + malloc(size); *ptr = malloc(size);                # ptr is  &write_where + SIZE_SZ
    + fake chunk on stack must be in correct fastbin, othwerwise you will get "malloc(): memory corruption (fast)"

        that means: (write_where>>4)-2 must be equal to fastbin index(idx) (counting from 0)
        that means: write_where == 0x40 -> previous mallocs were with same size

        fastbins:
        32:  0x1ce4000 ◂— idx==0x0
        48:  0x0
        64:  0x40 <-- write_where==0x40, so it must be: idx==2 (2 == 0x40>>4 - 2)
        80:  0x0
        96:  0x0
        112: 0x0
        128: 0x0


UNLINK
------------------------
* unsafe unlink
    + require:
        + free on corrupted chunk (overwritten prev_size + one bit)
        + pointer to chunk at know position

    chunk0(smallbin_size)
     ______
    |prev_size                                      fake_chunk inside chunk0
    |size                                            ______ 
    |fd                                             |prev_size == 0
    |bk                                             |size == 0
    |fd_nextsize = &chunk0_ptr - 3*SIZE_SZ          |fd: fake_chunk->fd->bk == fake_chunk
    |bk_nextsize = &chunk0_ptr - 2*SIZE_SZ          |bk: fake_chunk->bk->fd == fake_chunk
    |__________

    chunk1(smallbin_size) <- overflow
     _________
    |prev_size = smallbin_size (normally it would be smallbin_size+2*SIZE_SZ, but now it points to fake_chunk)
    |size &= ~1 (mark chunk0 as free, do not change size value except LSB)
    |fd
    |bk
    |________

    + malloc two chunks of size smallbin_size (NOT fastbin, >=0x80)
    + setup fake chunk
    + overflow in chunk1 header
    + now free chunk1, so that consolidate backward will unlink fake_chunk overwriting chunk0_ptr (now it points to fake_chunk->fd so &chunk0_ptr - 3*SIZE_SZ)
    + chunk0_ptr[3] = write_where
    + now chunk0_ptr points to write_where
    + chunk0_ptr[0] = write_what


HOUSE of SPIRIT
------------------------
* House of Spirit (free overwritten pointer)
    + require:
        + pointer to controlled memory
        + free on that pointer
        + malloc of fastbin size

    fake_chunk0
     ________
    |prev_size
    |size = fastbin_size (so next chunk is fake_chunk1), M and P bits must be zero
    |fd
    |bk
    |fd_nextsize
    |bk_nextsize
    |________

    fake_chunk1
     ________
    |prev_size
    |size = 0x2240 (above 2*SIZE_SZ, below av->system_mem (128kb by default for the main arena))
    |fd
    |bk
    |fd_nextsize
    |bk_nextsize
    |________

    + malloc whatever to setup heap
    + make two fake chunks
    + overwrite some pointer with &fake_chunk0+2*SIZE_SZ
    + free it, overwritten pointer will be in fastbins
    + malloc of size fastbin_size (or something near) will return &fake_chunk0[2]


HOUSE of FORCE
------------------------
* House of Force (overwrite top chunk's size field)
    + require:
        + known address of top chunk
        + overwritte top chunk's size
        + malloc of arbitrary size
        
    + set top chunk's size to -1 (0xffffffff or something big)
    + compute evil_size = write_where - sizeof(char *)*4 - top_chunk_address (top_chunk_address == prev_size)
    + be carefull with signed evil_size
    + malloc(evil_size) (it will return top_chunk_address+2*sizeof(char *) and set new top_chunk_address to write_where-2*sizeof(char *))
    + malloc(whatever) (it will return write_where)
    + profit
```

### glibc
```
cat makefile
GLIBC = /path/glibc_versions/2.25
CC = gcc

.PHONY: all
all: test

test: test.c
	${CC} \
	-Wl,-rpath=${GLIBC}:\
	${GLIBC}/math:\
	${GLIBC}/elf:\
	${GLIBC}/dlfcn:\
	${GLIBC}/nss:\
	${GLIBC}/nis:\
	${GLIBC}/rt:\
	${GLIBC}/resolv:\
	${GLIBC}/crypt:\
	${GLIBC}/nptl_db:\
	${GLIBC}/nptl:\
	-Wl,--dynamic-linker=${GLIBC}/elf/ld.so \
	-o test test.c

clean:
	rm -f test test.o
----------

# compile
gcc -Wl,-rpath=${GLIBC}:${GLIBC}/math:${GLIBC}/elf:${GLIBC}/dlfcn:${GLIBC}/nss:${GLIBC}/nis:${GLIBC}/rt:${GLIBC}/resolv:${GLIBC}/crypt:${GLIBC}/nptl:${GLIBC}/nptl_db:-Wl,--dynamic-linker=${GLIBC}/elf/ld.so -o test test.c

# run
LD_PRELOAD="$GLIBC/libc.so:$GLIBC/elf/ld.so:$GLIBC/nptl/libpthread.so" ./test

# gdb ./test
# set environment LD_PRELOAD=/path/glibc_versions/2.25/libc.so:/path/glibc_versions/2.25/elf/ld.so:/path/glibc_versions/2.25/nptl/libpthread.so
# set auto-load safe-path /path/glibc_versions/2.25/nptl_db/
# set libthread-db-search-path /path/glibc_versions/2.25/nptl_db/
```