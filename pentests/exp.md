---
title: Exploit notes
author: gros
layout: default
---

### IP control

```
- saved rip
- ptrs in got table
- malloc_hook (triggered f.e. with printf with large string), free_hook etc
- fini array
- vtable in _IO_FILE (stdin, stderr...), fe. flush in stdout vtable
- atexit, onexit
- handler for custom format in printf
```

### Random stuff

* techniques / bugs

    + fmt string bug without stack control:
        ```
        initial stack:
        stack[x   ] == 0xffff5566: 0xffff5576 -> 0xabcd
        stack[x+16] == 0xffff5576: 0xabcd

        we can %x$n and change 0xabcd to write_where, like 0x55555dead:
        stack[x   ] == 0xffff5566: 0xffff5576 -> 0x55555dead
        stack[x+16] == 0xffff5576: 0x55555dead -> 0x0

        and now we can %x+19$n and change value at 0x55555dead to write_what
        ```

    * partial overwrites
    * dynamic resovler (return to dl_resolve)
    * dt_debug traversal: find ptr in dynamic section, _r_debug struct...
    * when stdin and stdout are closed / redirected to stderr:
        * blind exploitation, like leak something in memory byte-by-byte by using infinite loops and connection closing
        * open /dev/pts/X twice
        * change used _IO_FILE->_fileno to stdin/stdout
    * can't controll some register directly with ROP gadgets? Try to control it by jumping to binary code or some libc function (like atoi can control rax) 
    * in init func there are nice rop gadgets:

        ```
        pop rbx,rbp,r12,r13,r14,r15
        mov rdx, r13
        mov rsi, r14
        mov edi, r15
        call [r12+rbx*8]
        ```
    * you can open "/proc/self/mem" on main function address with mode=2 and write there a shellcode


### Heap notes
```
For 32 bit systems:
     Max numbers of arenas = 2 * number of cores.
     SIZE_SZ = 4
For 64 bit systems:
     Max numbers of arenas = 8 * number of cores.
     SIZE_SZ = 8


struct malloc_chunk {
    INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */
    INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. 3LSB: N,M,P*/
    /* N(NON_MAIN_ARENA)-set if chunk belongs to thread arena, M(IS_MMAPPED), P(PREV_INUSE) */

    struct malloc_chunk* fd;         /* double links -- used only if free. */
    struct malloc_chunk* bk;

    /* Only used for large blocks: pointer to next larger size.  */
    struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
    struct malloc_chunk* bk_nextsize;
};

unsorted bin(1):

fastbins(10):
* bins of sizes 16-80, +8 each
* no coalescing
* single linked
* 0x30-0x38 are all rounded to 0x40 on x64

smallbin(62)
* less than 512
* from 16, +8 each
* coalescing

large bins(63)
* coalescing
* ordered


HOUSES
------------------------
The House of Prime: Requires two free's of chunks containing attacker controlled size fields, followed by a call to malloc.

The House of Mind: Requires the manipulation of the program into repeatedly allocating new memory.

The House of Force: Requires that we can overwrite the top chunk, that there is one malloc call with a user controllable size, and finally requires another call to malloc.

The House of Lore: Again not applicable to our example program.

The House of Spirit: One assumption is that the attacker controls a pointer given to free, so again this technique cannot be used.

The House of Chaos: This isn't actually a technique, just a section in the article :)
------------------------



FASTBIN
------------------------
* abusing the fastbin freelist (two times same value in fastbins list):
    + require:
        + double-free on chunk (fastbin size)
        + variable near write_where with value close to fastbin size 

    + malloc two chunks (same size, say 0x40)
    + free chunk1, chunk2, chunk1 (double free vuln);   # now fastbin list is HEAD->chunk1->chunk2->chunk1
    + d = malloc(size); malloc(size);                   # now the list is HEAD->chunk1 and we control content (fd, bk) of chunk1
    + write_where = 0x40                                # (or semething near fastbin size)
    + *d = &write_where - SIZE_SZ; 
    + malloc(size); *ptr = malloc(size);                # ptr is  &write_where + SIZE_SZ
    + fake chunk on stack must be in correct fastbin, othwerwise you will get "malloc(): memory corruption (fast)"

        that means: (write_where>>4)-2 must be equal to fastbin index(idx) (counting from 0)
        that means: write_where == 0x40 -> previous mallocs were with same size

        fastbins:
        32:  0x1ce4000 ◂— idx==0x0
        48:  0x0
        64:  0x40 <-- write_where==0x40, so it must be: idx==2 (2 == 0x40>>4 - 2)
        80:  0x0
        96:  0x0
        112: 0x0
        128: 0x0


UNLINK
------------------------
* unsafe unlink
    + require:
        + free on corrupted chunk (overwritten prev_size + one bit)
        + pointer to chunk at know position

    chunk0(smallbin_size)
     ______
    |prev_size                                      fake_chunk inside chunk0
    |size                                            ______ 
    |fd                                             |prev_size == 0
    |bk                                             |size == 0
    |fd_nextsize = &chunk0_ptr - 3*SIZE_SZ          |fd: fake_chunk->fd->bk == fake_chunk
    |bk_nextsize = &chunk0_ptr - 2*SIZE_SZ          |bk: fake_chunk->bk->fd == fake_chunk
    |__________

    chunk1(smallbin_size) <- overflow
     _________
    |prev_size = smallbin_size (normally it would be smallbin_size+2*SIZE_SZ, but now it points to fake_chunk)
    |size &= ~1 (mark chunk0 as free, do not change size value except LSB)
    |fd
    |bk
    |________

    + malloc two chunks of size smallbin_size (NOT fastbin, >=0x80)
    + setup fake chunk
    + overflow in chunk1 header
    + now free chunk1, so that consolidate backward will unlink fake_chunk overwriting chunk0_ptr (now it points to fake_chunk->fd so &chunk0_ptr - 3*SIZE_SZ)
    + chunk0_ptr[3] = write_where
    + now chunk0_ptr points to write_where
    + chunk0_ptr[0] = write_what


HOUSE of SPIRIT
------------------------
* House of Spirit (free overwritten pointer)
    + require:
        + pointer to controlled memory
        + free on that pointer
        + malloc of fastbin size

    fake_chunk0
     ________
    |prev_size
    |size = fastbin_size (so next chunk is fake_chunk1), M and P bits must be zero
    |fd
    |bk
    |fd_nextsize
    |bk_nextsize
    |________

    fake_chunk1
     ________
    |prev_size
    |size = 0x2240 (above 2*SIZE_SZ, below av->system_mem (128kb by default for the main arena))
    |fd
    |bk
    |fd_nextsize
    |bk_nextsize
    |________

    + malloc whatever to setup heap
    + make two fake chunks
    + overwrite some pointer with &fake_chunk0+2*SIZE_SZ
    + free it, overwritten pointer will be in fastbins
    + malloc of size fastbin_size (or something near) will return &fake_chunk0[2]


HOUSE of FORCE
------------------------
* House of Force (overwrite top chunk's size field)
    + require:
        + known address of top chunk
        + overwritte top chunk's size
        + malloc of arbitrary size
        
    + set top chunk's size to -1 (0xffffffff or something big)
    + compute evil_size = write_where - sizeof(char *)*4 - top_chunk_address (top_chunk_address == prev_size)
    + be carefull with signed evil_size
    + malloc(evil_size) (it will return top_chunk_address+2*sizeof(char *) and set new top_chunk_address to write_where-2*sizeof(char *))
    + malloc(whatever) (it will return write_where)
    + profit
```